# CPU Emulator

## 概要
[「動かしてわかる CPUの作り方10講」](https://www.amazon.co.jp/%E5%8B%95%E3%81%8B%E3%81%97%E3%81%A6%E3%82%8F%E3%81%8B%E3%82%8B-CPU%E3%81%AE%E4%BD%9C%E3%82%8A%E6%96%B910%E8%AC%9B-%E4%BA%95%E6%BE%A4-%E8%A3%95%E5%8F%B8/dp/4297108216)の第三章にて扱われている，高級言語によるCPUエミュレーターをPythonで再実装したもの．

以下を一連の流れで実行します．
1. 簡易的に定義したアセンブリ言語を受け取り，機械語（ビット列）に翻訳する
2. 機械語に基づきCPUの動作をエミュレーション

## 実行方法
1. 依存パッケージのインストール
    ```bash
    cd cpu_emulator
    uv sync
    ```
2. エミュレーションの実行
    ```bash
    uv run python example.py
    ```

## アセンブリ言語の仕様
### サンプル
```
ldl(1,1)
ldl(2,10)
add(3,1)
add(0,3)
cmp(2,3)
je(7)
jmp(2)
hlt()
```
### 想定しているCPUの仕様

| 項目        | 仕様              |
| --------- | --------------- |
| データ幅      | 16 bit          |
| レジスタ数     | 8 （アドレス幅 3 bit） |
| メモリアドレス幅  | 8 bit           |
| プログラムカウンタ | 8 bit           |
| フラグ       | 1 bit（条件分岐用）    |

メモリやレジスタはプログラム開始時に0に初期化される．

### 命令の仕様
- 機械語は15bit固定長（詳しくは書籍を参照）
- 可読性のため別途`mov(1,2)`のような二モニックを用意
    - 空白，改行は無視される
- 特に記載がない場合，各命令の実行後にプログラムカウンタは1進む

| ニーモニック        | 説明                           |
| ------------- | ---------------------------- |
| **mov(x, y)** | レジスタ *y* → レジスタ *x*          |
| **add(x, y)** | *x* ← *x* + *y*              |
| **sub(x, y)** | *x* ← *x* − *y*              |
| **and(x, y)** | *x* ← *x* & *y*              |
| **or(x, y)**  | *x* ← *x* \| *y*             |
| **sl(x)**     | *x* を左へ 1 bit シフト            |
| **sr(x)**     | *x* を右へ 1 bit 論理シフト（最上位bit ← 0） |
| **sra(x)**    | *x* を右へ 1 bit 算術シフト（最上位bit 保持）  |
| **ldl(x, y)** | *x* の下位 8 bit ← *y*          |
| **ldh(x, y)** | *x* の上位 8 bit ← *y*          |
| **cmp(x, y)** | *x* と *y* を比較し、等しければフラグ ← 1 そうでなければ，フラグ　← 0 |
| **je(addr)**  | フラグ = 1 なら PC ← *addr*       |
| **jmp(addr)** | 無条件で PC ← *addr*             |
| **ld(x, y)**  | メモリ\[*y*] → レジスタ *x*         |
| **st(x, y)**  | レジスタ *x* → メモリ\[*y*]         |
| **hlt()**     | プログラムを停止                     |





## テスト
`cpu_emulator`ディレクトリで以下のコマンドを実行．
```bash
uv run pytest
```
